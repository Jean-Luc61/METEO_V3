<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Dashboard M√©t√©o Local ‚Äì V3+</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet (carte interactive) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root {
      --bg-main-day: linear-gradient(135deg, #2a6fb8, #5f9ed6, #8ec5fc);
      --bg-main-night: linear-gradient(135deg, #0d1525, #181f3c, #24365c);
      --card-bg-day: rgba(10, 30, 60, 0.95);
      --card-bg-night: rgba(10, 14, 30, 0.95);
      --card-border-day: rgba(255, 255, 255, 0.18);
      --card-border-night: rgba(255, 255, 255, 0.06);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--bg-main-night);
      color: #f7f7f7;
      padding: 20px;
      transition: background 0.8s ease, font-size 0.3s ease;
    }

    body.day-theme {
      background: var(--bg-main-day);
    }

    body.compact {
      font-size: 0.9rem;
    }

    h1 {
      margin-bottom: 4px;
      font-size: 2rem;
      font-weight: 600;
    }

    #topBar {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 14px;
      font-size: 0.95rem;
      color: #d0d7e5;
      max-width: 1600px;
      margin-left: auto;
      margin-right: auto;
    }

    #topRow {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }

    #locationTitle {
      font-size: 0.95rem;
    }

    .location-select {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .location-select label {
      font-size: 0.9rem;
    }

    .location-select select {
      background: rgba(7, 10, 22, 0.85);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      color: #f7f7f7;
      padding: 4px 8px;
      font-size: 0.9rem;
    }

    .location-select button {
      background: #b64040;
      border: none;
      border-radius: 6px;
      color: #fff;
      padding: 4px 10px;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .location-select button[disabled] {
      opacity: 0.4;
      cursor: default;
    }

    #updateInfo {
      font-size: 0.85rem;
      color: #d0d7e5;
    }

    .location-custom {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
    }

    .location-custom label {
      opacity: 0.9;
    }

    .location-custom input {
      background: rgba(7, 10, 22, 0.9);
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      color: #f7f7f7;
      padding: 3px 6px;
      font-size: 0.85rem;
      width: 90px;
    }

    .location-custom input#nameInput {
      width: 140px;
    }

    .location-custom button {
      background: #2f7bd8;
      border: none;
      border-radius: 6px;
      color: #fff;
      padding: 4px 10px;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .location-custom button:hover {
      filter: brightness(1.1);
    }

    .top-buttons {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .top-buttons-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .theme-toggle button,
    .layout-toggle button {
      background: #444a7a;
      border: none;
      border-radius: 6px;
      color: #fff;
      padding: 4px 10px;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .theme-toggle button:hover,
    .layout-toggle button:hover {
      filter: brightness(1.1);
    }

    /* Grille principale : 3 colonnes sur grand √©cran */
    .dashboard {
      max-width: 1600px;
      margin: 0 auto;
      display: grid;

      grid-template-columns: 2.1fr 1.2fr 1.1fr;
      grid-template-areas:
        "radar    radar    atm"
        "radar    radar    current"
        "rain     temp24   temp24"
        "forecast forecast map"
        "wind     wind     map"
        "compare  aqi      storms"
        "history  summary  miniradar"
        "sun      alerts   miniradar";

      gap: 18px;
      transition: gap 0.3s ease;
    }

    body.compact .dashboard {
      gap: 10px;
    }

    .card {
      background: var(--card-bg-night);
      border-radius: 12px;
      padding: 14px 16px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
      border: 1px solid var(--card-border-night);
      transition: background 0.6s ease, border-color 0.6s ease, padding 0.3s ease;
    }

    body.day-theme .card {
      background: var(--card-bg-day);
      border-color: var(--card-border-day);
    }

    body.compact .card {
      padding: 10px 12px;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 6px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      padding-bottom: 4px;
    }

    .card-header h2 {
      font-size: 1.15rem;
      font-weight: 600;
      color: #ffe38a;
      letter-spacing: 0.02em;
    }

    .card-header small {
      color: #9ba6c3;
      font-size: 0.8rem;
    }

    /* Placement des cartes dans la grille */
    #radarCard    { grid-area: radar; }
    #atmCard      { grid-area: atm; font-size: 0.85rem; }
    #rainCard     { grid-area: rain; }
    #temp24Card   { grid-area: temp24; }
    #windCard     { grid-area: wind; }
    #currentCard  { grid-area: current; display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap; }
    #sunCard      { grid-area: sun; }
    #forecastCard { grid-area: forecast; }
    #alertsCard   { grid-area: alerts; }
    #historyCard  { grid-area: history; }
    #summaryCard  { grid-area: summary; }
    #compareCard  { grid-area: compare; }
    #mapCard      { grid-area: map; }
    #aqiCard      { grid-area: aqi; }
    #stormCard    { grid-area: storms; }
    #miniRadarCard{ grid-area: miniradar; }

    .current-main {
      font-size: 1rem;
    }

    .current-temp {
      font-size: 2.4rem;
      font-weight: 600;
      text-align: right;
    }

    body.compact .current-temp {
      font-size: 2rem;
    }

    .current-extra {
      font-size: 0.9rem;
      color: #c3cbe0;
      text-align: right;
    }

    .radar-container {
      position: relative;
      width: 100%;
      padding-top: 62%;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.15);
      margin-bottom: 6px;
    }

    .radar-container.mini {
      padding-top: 60%;
    }

    .radar-container iframe {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      border: 0;
    }

    .radar-toggle-bar {
      display: inline-flex;
      gap: 6px;
      margin-bottom: 8px;
      font-size: 0.85rem;
    }

    .radar-toggle-btn {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.35);
      background: rgba(7, 10, 22, 0.7);
      color: #d5def5;
      padding: 3px 10px;
      cursor: pointer;
      user-select: none;
    }

    .radar-toggle-btn.active {
      background: #2f7bd8;
      color: #fff;
      border-color: #72a8ff;
      font-weight: 500;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    th, td {
      padding: 6px 4px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      text-align: left;
    }

    table thead tr {
      background: rgba(255, 255, 255, 0.04);
    }

    th {
      font-weight: 600;
      font-size: 0.92rem;
      color: #f5f7ff;
    }

    .alerts-list {
      list-style: none;
      font-size: 0.9rem;
    }

    .alerts-list li {
      margin-bottom: 6px;
      padding-left: 20px;
      position: relative;
      color: #f3e3a0;
    }

    .alerts-list li::before {
      content: "‚ö†";
      position: absolute;
      left: 0;
      top: 0;
      font-size: 0.9rem;
    }

    .sun-row, .atm-row, .aqi-row, .storm-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.9rem;
      margin-bottom: 4px;
    }

    .sun-label, .atm-label, .aqi-label, .storm-label {
      color: #b3bdd8;
    }

    .sun-value, .atm-value, .aqi-value, .storm-value {
      font-weight: 500;
      color: #f6f7ff;
    }

    /* Graph pluie & m√©t√©ogramme */
    #rainChart {
      width: 100%;
      height: 140px;
      background: radial-gradient(circle at 10% 0, #3a567f, #151a28);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      margin-bottom: 4px;
    }

    #temp24Chart {
      width: 100%;
      height: 240px;
      background: radial-gradient(circle at 10% 0, #3a567f, #151a28);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      margin-bottom: 4px;
    }

    .summary-text {
      font-size: 0.9rem;
      color: #d4daec;
      line-height: 1.4;
      margin-top: 4px;
    }

    .error-text {
      font-size: 0.9rem;
      color: #ffb3b3;
      margin-top: 6px;
    }

    .wind-compass {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .wind-circle {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.6);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .wind-arrow {
      width: 2px;
      height: 28px;
      background: #4fc3ff;
      position: absolute;
      bottom: 50%;
      transform-origin: bottom center;
    }

    .wind-arrow::after {
      content: "";
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 10px solid #4fc3ff;
    }

    .wind-dir-label {
      position: absolute;
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.85);
      pointer-events: none;
    }

    .wind-N { top: 4px; left: 50%; transform: translateX(-50%); }
    .wind-S { bottom: 4px; left: 50%; transform: translateX(-50%); }
    .wind-E { right: 4px; top: 50%; transform: translateY(-50%); }
    .wind-O { left: 4px; top: 50%; transform: translateY(-50%); }

    .wind-labels {
      font-size: 0.85rem;
      color: #c3cbe0;
    }

    .history-table td {
      font-size: 0.85rem;
    }

    #leafletMap {
      width: 100%;
      height: 230px;
      border-radius: 8px;
      overflow: hidden;
    }

    /* Mode mobile / petit √©cran : une seule colonne */
    @media (max-width: 950px) {
      body { padding: 12px; }

      .dashboard {
        grid-template-columns: 1fr;
        grid-template-areas:
          "radar"
          "atm"
          "current"
          "rain"
          "temp24"
          "forecast"
          "compare"
          "map"
          "wind"
          "sun"
          "alerts"
          "aqi"
          "storms"
          "miniradar"
          "history"
          "summary";
      }

      .current-temp { font-size: 2.1rem; }
      body.compact .current-temp { font-size: 1.8rem; }
    }

    /* AQI badge (fond color√©) */
    .aqi-badge {
      padding: 4px 10px;
      border-radius: 8px;
      font-weight: 600;
      color: #fff;
      display: inline-block;
    }

    .aqi-good      { background-color: #2ecc71; }
    .aqi-fair      { background-color: #a2d729; }
    .aqi-moderate  { background-color: #f1c40f; }
    .aqi-poor      { background-color: #e67e22; }
    .aqi-very-poor { background-color: #e74c3c; }

    /* Badge risque orageux */
    .storm-badge {
      padding: 4px 10px;
      border-radius: 8px;
      font-weight: 600;
      color: #fff;
      display: inline-block;
    }

    .storm-low      { background-color: #2ecc71; }  /* Faible ‚Üí vert */
    .storm-moderate { background-color: #f1c40f; }  /* Mod√©r√© ‚Üí jaune */
    .storm-marked   { background-color: #e67e22; }  /* Marqu√© ‚Üí orange */
    .storm-strong   { background-color: #e74c3c; }  /* Fort ‚Üí rouge */
  </style>
</head>
<body>
  <div id="topBar">
    <div id="topRow">
      <div>
        <h1>Dashboard M√©t√©o Local ‚Äì V3+</h1>
        <div id="locationTitle"></div>
      </div>

      <div class="location-select">
        <label for="locationSelect">Lieu :</label>
        <select id="locationSelect"></select>
        <button id="deleteLocationBtn" type="button">Supprimer</button>
        <span id="updateInfo"></span>
      </div>

      <div class="top-buttons">
        <div class="top-buttons-row">
          <div class="theme-toggle">
            <button id="themeToggleBtn" type="button">Th√®me : Auto</button>
          </div>
          <div class="layout-toggle">
            <button id="layoutToggleBtn" type="button">Mode : Large</button>
          </div>
        </div>
      </div>
    </div>

    <div class="location-custom">
      <label>Ajouter GPS :</label>
      <input id="nameInput" type="text" placeholder="Nom (optionnel)" />
      <span>Lat :</span>
      <input id="latInput" type="number" step="0.01" placeholder="48.75" />
      <span>Lon :</span>
      <input id="lonInput" type="number" step="0.01" placeholder="-0.57" />
      <button id="addLocationBtn">Ajouter</button>
      <button id="geoLocateBtn" type="button">üìç Ma position</button>
    </div>
  </div>

  <main class="dashboard">
    <!-- Radar principal -->
    <section class="card" id="radarCard">
      <div class="card-header">
        <h2>Radar local</h2>
        <small id="radarModeLabel">Windy ‚Äì radar m√©t√©o (dBZ)</small>
      </div>
      <div class="radar-toggle-bar">
        <button type="button" id="btnRadarMode" class="radar-toggle-btn radar active">
          Radar m√©t√©o
        </button>
        <button type="button" id="btnRainMode" class="radar-toggle-btn rain">
          Pluie (mm/h)
        </button>
      </div>
      <div class="radar-container">
        <iframe id="radarFrame" loading="lazy" allowfullscreen></iframe>
      </div>
      <p class="summary-text" id="radarSummary"></p>
    </section>

    <!-- Param√®tres atmos -->
    <section class="card" id="atmCard">
      <div class="card-header">
        <h2>Param√®tres atmosph√©riques</h2>
        <small>Pression, humidit√©, point de ros√©e</small>
      </div>
      <div id="atmContent"></div>
    </section>

    <!-- Situation actuelle -->
    <section class="card" id="currentCard">
      <div class="current-main" id="currentMain"></div>
      <div>
        <div class="current-temp" id="currentTemp"></div>
        <div class="current-extra" id="currentExtra"></div>
      </div>
    </section>

    <!-- Pluie dans l‚Äôheure -->
    <section class="card" id="rainCard">
      <div class="card-header">
        <h2>Pluie dans l‚Äôheure</h2>
        <small>√âchelle 1 h (OpenWeather, pr√©vision 3 h interpol√©e)</small>
      </div>
      <canvas id="rainChart"></canvas>
      <p class="summary-text" id="rainSummary"></p>
      <p class="error-text" id="rainError"></p>
    </section>

    <!-- M√©t√©ogramme 24 h -->
    <section class="card" id="temp24Card">
      <div class="card-header">
        <h2>M√©t√©ogramme 24 h</h2>
        <small>Temp√©rature (courbe) &amp; pluie (barres)</small>
      </div>
      <canvas id="temp24Chart"></canvas>
    </section>

    <!-- Pr√©vision courte & quotidienne -->
    <section class="card" id="forecastCard">
      <div class="card-header">
        <h2>Pr√©vision courte &amp; quotidienne</h2>
        <small>Mod√®le 3 h OpenWeather</small>
      </div>
      <table id="shortTable">
        <thead>
          <tr>
            <th>Heure</th>
            <th>Temp (¬∞C)</th>
            <th>Pluie (mm/3h)</th>
            <th>Vent (km/h)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <br />
      <table id="dailyTable">
        <thead>
          <tr>
            <th>Jour</th>
            <th>Min (¬∞C)</th>
            <th>Max (¬∞C)</th>
            <th>Pluie (mm)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>

    <!-- Vent -->
    <section class="card" id="windCard">
      <div class="card-header">
        <h2>Vent</h2>
        <small>Direction et intensit√©</small>
      </div>
      <div class="wind-compass">
        <div class="wind-circle">
          <div class="wind-arrow" id="windArrow"></div>
          <span class="wind-dir-label wind-N">N</span>
          <span class="wind-dir-label wind-S">S</span>
          <span class="wind-dir-label wind-E">E</span>
          <span class="wind-dir-label wind-O">O</span>
        </div>
        <div class="wind-labels" id="windLabels"></div>
      </div>
    </section>

    <!-- Comparaison mod√®les -->
    <section class="card" id="compareCard">
      <div class="card-header">
        <h2>Comparaison mod√®les</h2>
        <small>OpenWeather vs M√©t√©o-France (AROME/ARPEGE)</small>
      </div>
      <table id="compareTable">
        <thead>
          <tr>
            <th>Heure</th>
            <th>Temp OW (¬∞C)</th>
            <th>Temp OM (¬∞C)</th>
            <th>Pluie OW / OM (mm)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>

    <!-- Carte Leaflet -->
    <section class="card" id="mapCard">
      <div class="card-header">
        <h2>Carte m√©t√©o locale</h2>
        <small>Fond OpenStreetMap & position</small>
      </div>
      <div id="leafletMap"></div>
    </section>

    <!-- Soleil & Lune -->
    <section class="card" id="sunCard">
      <div class="card-header">
        <h2>Soleil &amp; Lune</h2>
        <small>√âph√©m√©rides locales</small>
      </div>
      <div id="sunMoonBlock"></div>
    </section>

    <!-- Alertes -->
    <section class="card" id="alertsCard">
      <div class="card-header">
        <h2>Alertes</h2>
      </div>
      <ul class="alerts-list" id="alertsList"></ul>
    </section>

    <!-- Qualit√© de l'air -->
    <section class="card" id="aqiCard">
      <div class="card-header">
        <h2>Qualit√© de l'air</h2>
        <small>Multi-sources (OpenWeather / BreezoMeter / Atmo)</small>
      </div>
      <div id="aqiContent"></div>
    </section>

    <!-- Orages & instabilit√© -->
    <section class="card" id="stormCard">
      <div class="card-header">
        <h2>Orages & instabilit√©</h2>
        <small>Indice simple (Open-Meteo / M√©t√©o-France)</small>
      </div>
      <div id="stormContent"></div>
    </section>

    <!-- Radar mini -->
    <section class="card" id="miniRadarCard">
      <div class="card-header">
        <h2>Radar mini</h2>
        <small>Aper√ßu rapide (radar)</small>
      </div>
      <div class="radar-container mini">
        <iframe id="miniRadarFrame" loading="lazy" allowfullscreen></iframe>
      </div>
    </section>

    <!-- Historique -->
    <section class="card" id="historyCard">
      <div class="card-header">
        <h2>Historique de session</h2>
        <small>Derni√®res mises √† jour</small>
      </div>
      <table class="history-table">
        <thead>
          <tr>
            <th>Heure</th>
            <th>Temp (¬∞C)</th>
            <th>Vent (km/h)</th>
          </tr>
        </thead>
        <tbody id="historyBody"></tbody>
      </table>
    </section>

    <!-- R√©sum√© -->
    <section class="card" id="summaryCard">
      <div class="card-header">
        <h2>R√©sum√©</h2>
      </div>
      <p class="summary-text" id="textSummary"></p>
      <p class="error-text" id="globalError"></p>
    </section>
  </main>

  <script>
    // ------------- CONFIG -------------
    const API_KEY = "10afa751c6a2b85e16dcf699a9392307";
  // BreezoMeter (optionnel)
  const BREEZO_API_KEY = ""; // <-- colle ta cl√© ici, sinon laisse vide
 // <-- ta cl√© OW
    const OPENMETEO_BASE = "https://api.open-meteo.com/v1/meteofrance";

    const BASE_LOCATIONS = {
      flers: { name: "Flers", lat: 48.75, lon: -0.57, base: true },
      caen:  { name: "Caen",  lat: 49.18, lon: -0.36, base: true },
      paris: { name: "Paris", lat: 48.86, lon:  2.35, base: true },
      maison: { name: "Maison", lat: 48.825751, lon:  -0.491764, base: true },
      pascal: { name: "Pascal", lat: 46.218499, lon:  -0.632202, base: true },
      fourdata: { name: "Four Data", lat: 47.326572, lon:  5.024075, base: true },
    };

    const STORAGE_CUSTOM = "meteo_v3_custom_locations";
    const STORAGE_CURRENT = "meteo_v3_current_location";
    const STORAGE_RADAR_MODE = "meteo_v3_radar_mode";
    const STORAGE_THEME_MODE = "meteo_v3_theme_mode";
    const STORAGE_LAYOUT_MODE = "meteo_v3_layout_mode";

    let customLocations = [];
    let LOCATIONS = {};
    let locationOrder = [];
    let currentLocationKey = "flers";
    let historyEntries = [];

    let radarMode = "radar";
    let themeMode = "auto";
    let compactMode = false;

    let lastSunInfo = null;

    let leafletMap = null;
    let leafletMarker = null;
    const GEO_KEY = "geo_current"; // lieu sp√©cial pour la g√©olocalisation

    // ------------- OUTILS -------------

    function formatTimeHMFromDate(d) {
      const h = d.getHours().toString().padStart(2, "0");
      const m = d.getMinutes().toString().padStart(2, "0");
      return `${h}h${m}`;
    }

    function toHMFromUnix(ts) {
      if (!ts) return "‚Äî";
      const d = new Date(ts * 1000);
      return d.toLocaleTimeString("fr-FR", { hour: "2-digit", minute: "2-digit" });
    }

    function degToCardinal(deg) {
      if (typeof deg !== "number") return "‚Äî";
      const dirs = ["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSO","SO","OSO","O","ONO","NO","NNO"];
      const ix = Math.round((deg % 360) / 22.5) % 16;
      return dirs[ix];
    }

    function translateWeatherDesc(desc) {
      if (!desc) return "conditions inconnues";
      return desc.charAt(0).toUpperCase() + desc.slice(1);
    }

    function computeDewPoint(tempC, humidity) {
      if (tempC == null || humidity == null || humidity <= 0) return null;
      const a = 17.27;
      const b = 237.7;
      const alpha = Math.log(humidity / 100) + (a * tempC) / (b + tempC);
      const Td = (b * alpha) / (a - alpha);
      return Td;
    }

    // ------------- LOCALSTORAGE -------------

    function loadCustomLocations() {
      try {
        const raw = localStorage.getItem(STORAGE_CUSTOM);
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) customLocations = arr;
      } catch {}
    }

    function saveCustomLocations() {
      try {
        localStorage.setItem(STORAGE_CUSTOM, JSON.stringify(customLocations));
      } catch {}
    }

    function loadCurrentLocationKey() {
      try {
        const k = localStorage.getItem(STORAGE_CURRENT);
        if (k) currentLocationKey = k;
      } catch {}
    }

    function saveCurrentLocationKey() {
      try {
        localStorage.setItem(STORAGE_CURRENT, currentLocationKey);
      } catch {}
    }

    function loadRadarMode() {
      try {
        const m = localStorage.getItem(STORAGE_RADAR_MODE);
        if (m === "radar" || m === "rain") radarMode = m;
      } catch {}
    }

    function saveRadarMode() {
      try {
        localStorage.setItem(STORAGE_RADAR_MODE, radarMode);
      } catch {}
    }

    function loadThemeMode() {
      try {
        const m = localStorage.getItem(STORAGE_THEME_MODE);
        if (m === "auto" || m === "day" || m === "night") themeMode = m;
      } catch {}
    }

    function saveThemeMode() {
      try {
        localStorage.setItem(STORAGE_THEME_MODE, themeMode);
      } catch {}
    }

    function loadLayoutMode() {
      try {
        const m = localStorage.getItem(STORAGE_LAYOUT_MODE);
        if (m === "compact") compactMode = true;
      } catch {}
    }

    function saveLayoutMode() {
      try {
        localStorage.setItem(STORAGE_LAYOUT_MODE, compactMode ? "compact" : "large");
      } catch {}
    }

    // ------------- LIEUX -------------

    function rebuildLocations() {
      LOCATIONS = {};
      locationOrder = [];
      for (const key of Object.keys(BASE_LOCATIONS)) {
        LOCATIONS[key] = BASE_LOCATIONS[key];
        locationOrder.push(key);
      }
      customLocations.forEach(loc => {
        LOCATIONS[loc.key] = { name: loc.name, lat: loc.lat, lon: loc.lon, base: false };
        locationOrder.push(loc.key);
      });
    }

    function rebuildLocationSelect() {
      const select = document.getElementById("locationSelect");
      select.innerHTML = "";
      locationOrder.forEach(key => {
        const loc = LOCATIONS[key];
        const opt = document.createElement("option");
        opt.value = key;
        opt.textContent = loc.name;
        select.appendChild(opt);
      });
      if (!LOCATIONS[currentLocationKey]) {
        currentLocationKey = locationOrder[0] || "flers";
      }
      select.value = currentLocationKey;
      updateDeleteButtonState();
    }

    function updateDeleteButtonState() {
      const btn = document.getElementById("deleteLocationBtn");
      if (!btn) return;
      btn.disabled = !!(LOCATIONS[currentLocationKey] && LOCATIONS[currentLocationKey].base);
    }

    function handleAddLocation() {
      const nameInput = document.getElementById("nameInput");
      const latInput = document.getElementById("latInput");
      const lonInput = document.getElementById("lonInput");
      const lat = parseFloat(latInput.value.replace(",", "."));
      const lon = parseFloat(lonInput.value.replace(",", "."));
      if (Number.isNaN(lat) || Number.isNaN(lon)) {
        alert("Latitude ou longitude invalide.");
        return;
      }
      let name = nameInput.value.trim();
      if (!name) name = `Perso (${lat.toFixed(2)}, ${lon.toFixed(2)})`;
      const key = "user_" + Date.now();
      customLocations.push({ key, name, lat, lon });
      saveCustomLocations();
      rebuildLocations();
      currentLocationKey = key;
      saveCurrentLocationKey();
      rebuildLocationSelect();
      updateRadarFrames();
      historyEntries = [];
      document.getElementById("historyBody").innerHTML = "";
      loadAndRender();
    }

    function handleDeleteLocation() {
      const key = currentLocationKey;
      const loc = LOCATIONS[key];
      if (!loc) return;
      if (loc.base) {
        alert("Les lieux de base ne peuvent pas √™tre supprim√©s.");
        return;
      }
      if (!confirm("Supprimer ce lieu personnalis√© ?")) return;
      const idx = customLocations.findIndex(l => l.key === key);
      if (idx !== -1) {
        customLocations.splice(idx, 1);
        saveCustomLocations();
      }
      rebuildLocations();
      currentLocationKey = locationOrder[0] || "flers";
      saveCurrentLocationKey();
      rebuildLocationSelect();
      updateRadarFrames();
      historyEntries = [];
      document.getElementById("historyBody").innerHTML = "";
      loadAndRender();
    }

    // ------------- GEOLOCALISATION -------------
    function applyGeoLocation(lat, lon) {
      const name = "Ma position";

      // Met √† jour ou cr√©e le lieu sp√©cial
      const idx = customLocations.findIndex(l => l.key === GEO_KEY);
      const locObj = { key: GEO_KEY, name, lat, lon };

      if (idx !== -1) {
        customLocations[idx] = locObj;
      } else {
        customLocations.push(locObj);
      }

      saveCustomLocations();
      rebuildLocations();

      currentLocationKey = GEO_KEY;
      saveCurrentLocationKey();
      rebuildLocationSelect();
      updateRadarFrames();

      historyEntries = [];
      const tbody = document.getElementById("historyBody");
      if (tbody) tbody.innerHTML = "";

      loadAndRender();
    }

    function askGeolocation() {
      if (!("geolocation" in navigator)) {
        alert("La g√©olocalisation n‚Äôest pas support√©e par ce navigateur.");
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          applyGeoLocation(lat, lon);
        },
        (err) => {
          console.error(err);
          alert("Impossible de r√©cup√©rer la position : " + err.message);
        },
        {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 600000
        }
      );
    }



    // ------------- THEME & LAYOUT -------------

    function applyTheme(sunInfo) {
      const body = document.body;
      const btn = document.getElementById("themeToggleBtn");

      if (themeMode === "day") {
        body.classList.add("day-theme");
        btn.textContent = "Th√®me : Jour";
        return;
      }
      if (themeMode === "night") {
        body.classList.remove("day-theme");
        btn.textContent = "Th√®me : Nuit";
        return;
      }

      btn.textContent = "Th√®me : Auto";
      if (!sunInfo || sunInfo.sunriseUnix == null || sunInfo.sunsetUnix == null) return;
      const now = new Date();
      const isDay = now.getTime() >= sunInfo.sunriseUnix * 1000 &&
                    now.getTime() <= sunInfo.sunsetUnix * 1000;
      if (isDay) body.classList.add("day-theme");
      else body.classList.remove("day-theme");
    }

    function toggleThemeMode() {
      if (themeMode === "auto") {
        themeMode = "day";
      } else if (themeMode === "day") {
        themeMode = "night";
      } else {
        themeMode = "auto";
      }
      saveThemeMode();
      applyTheme(lastSunInfo);
    }

    function applyLayoutMode() {
      const body = document.body;
      const btn = document.getElementById("layoutToggleBtn");
      if (compactMode) {
        body.classList.add("compact");
        btn.textContent = "Mode : Compact";
      } else {
        body.classList.remove("compact");
        btn.textContent = "Mode : Large";
      }
    }

    function toggleLayoutMode() {
      compactMode = !compactMode;
      saveLayoutMode();
      applyLayoutMode();
    }

    // ------------- RADAR -------------

    function updateRadarToggleUI() {
      const btnRadar = document.getElementById("btnRadarMode");
      const btnRain = document.getElementById("btnRainMode");
      const label = document.getElementById("radarModeLabel");
      if (!btnRadar || !btnRain || !label) return;

      if (radarMode === "radar") {
        btnRadar.classList.add("active");
        btnRain.classList.remove("active");
        label.textContent = "Windy ‚Äì radar m√©t√©o (dBZ)";
      } else {
        btnRain.classList.add("active");
        btnRadar.classList.remove("active");
        label.textContent = "Windy ‚Äì pluie (mm/h)";
      }
    }

    function buildWindyUrl(loc, zoom, overlay) {
      return (
        "https://embed.windy.com/embed2.html" +
        `?lat=${loc.lat}&lon=${loc.lon}` +
        `&detailLat=${loc.lat}&detailLon=${loc.lon}` +
        `&zoom=${zoom}&level=surface` +
        overlay +
        "&menu=&message=true&marker=true" +
        "&calendar=now&pressure=true&type=map" +
        "&location=coordinates&detail=&metricWind=metric&metricTemp=metric&radarRange=-1"
      );
    }

    function updateRadarFrame() {
      const loc = LOCATIONS[currentLocationKey];
      if (!loc) return;
      const radarFrame = document.getElementById("radarFrame");
      let overlayPart = radarMode === "radar" ? "&overlay=radar" : "&overlay=rain&product=ecmwf";
      radarFrame.src = buildWindyUrl(loc, 8, overlayPart);
      updateRadarToggleUI();
    }

    function updateMiniRadarFrame() {
      const loc = LOCATIONS[currentLocationKey];
      if (!loc) return;
      const iframe = document.getElementById("miniRadarFrame");
      iframe.src = buildWindyUrl(loc, 5, "&overlay=radar");
    }

    function updateRadarFrames() {
      updateRadarFrame();
      updateMiniRadarFrame();
    }

    // ------------- LEAFLET -------------

    function initLeafletMap() {
      if (leafletMap) return;
      leafletMap = L.map("leafletMap").setView([48.75, -0.57], 7);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "Donn√©es ¬© OpenStreetMap"
      }).addTo(leafletMap);
      leafletMarker = L.marker([48.75, -0.57]).addTo(leafletMap);
    }

    function updateLeafletMap(loc) {
      if (!leafletMap) {
        initLeafletMap();
      }
      leafletMap.setView([loc.lat, loc.lon], 8);
      leafletMarker.setLatLng([loc.lat, loc.lon]);
    }

    // ------------- CONSTRUCTION DES DONN√âES -------------

    function buildRainTimelineFromForecast(list) {
      if (!Array.isArray(list) || list.length < 2) {
        return { peak: 0, timeline: [0,0,0,0,0,0,0], nextRain: null, endRain: null };
      }
      const intens3h = list.slice(0, 4).map(e => {
        const rain3h = e.rain && typeof e.rain["3h"] === "number" ? e.rain["3h"] : 0;
        return rain3h / 3;
      });
      const hourly = [];
      for (let k = 0; k < intens3h.length - 1; k++) {
        const i0 = intens3h[k];
        const i1 = intens3h[k + 1];
        for (let h = 0; h < 3; h++) {
          const alpha = h / 3;
          hourly.push((1 - alpha) * i0 + alpha * i1);
        }
      }
      const values = hourly.slice(0, 7);
      const peak = Math.max(...values, 0);
      let first = -1, last = -1;
      for (let i = 0; i < values.length; i++) {
        if (values[i] > 0.1) {
          if (first === -1) first = i;
          last = i;
        }
      }
      const now = new Date();
      let nextRain = null, endRain = null;
      if (first !== -1) nextRain = new Date(now.getTime() + first * 60*60*1000);
      if (last !== -1) endRain = new Date(now.getTime() + (last+1) * 60*60*1000);
      return { peak, timeline: values, nextRain, endRain };
    }

    function buildShortForecast(list) {
      if (!Array.isArray(list)) return { hours: [] };
      const slice = list.slice(0, 3);
      const hours = slice.map(e => {
        const d = new Date(e.dt * 1000);
        const rain3h = e.rain && typeof e.rain["3h"] === "number" ? e.rain["3h"] : 0;
        const windKmh = typeof e.wind.speed === "number" ? e.wind.speed * 3.6 : null;
        return {
          time: d.toLocaleTimeString("fr-FR", { hour: "2-digit", minute: "2-digit" }),
          temp_c: e.main.temp,
          rain_mm_3h: rain3h,
          wind_kmh: windKmh
        };
      });
      return { hours };
    }

    function buildTemp24(list) {
      if (!Array.isArray(list)) return { temps: [], labels: [], rain: [] };
      const slice = list.slice(0, 8);
      const temps = slice.map(e => e.main.temp);
      const rain = slice.map(e => e.rain && typeof e.rain["3h"] === "number" ? e.rain["3h"] : 0);
      const labels = slice.map(e => {
        const d = new Date(e.dt * 1000);
        return d.toLocaleTimeString("fr-FR", { hour: "2-digit" }).replace(":", "h");
      });
      return { temps, labels, rain };
    }

    function buildSunInfo(sys) {
      if (!sys) {
        return {
          sunrise: "‚Äî",
          sunset: "‚Äî",
          sunriseUnix: null,
          sunsetUnix: null,
          golden_hour_evening: ["‚Äî","‚Äî"],
          blue_hour_evening: ["‚Äî","‚Äî"],
          moon_phase: "Non disponible"
        };
      }
      const sunrise = toHMFromUnix(sys.sunrise);
      const sunriseUnix = sys.sunrise;
      const sunsetUnix = sys.sunset;
      const sunsetDate = new Date(sunsetUnix * 1000);
      const ghStart = new Date(sunsetDate.getTime() - 60*60*1000);
      const ghEnd   = sunsetDate;
      const bhStart = sunsetDate;
      const bhEnd   = new Date(sunsetDate.getTime() + 30*60*1000);
      return {
        sunrise,
        sunset: formatTimeHMFromDate(sunsetDate),
        sunriseUnix,
        sunsetUnix,
        golden_hour_evening: [formatTimeHMFromDate(ghStart), formatTimeHMFromDate(ghEnd)],
        blue_hour_evening:   [formatTimeHMFromDate(bhStart), formatTimeHMFromDate(bhEnd)],
        moon_phase: "Non disponible"
      };
    }

    function buildTextSummary(current, rainInfo, firstFc, locationName) {
      const parts = [];
      if (current && current.main && current.weather && current.weather[0]) {
        const desc = translateWeatherDesc(current.weather[0].description);
        const temp = current.main.temp;
        const windSp = current.wind && typeof current.wind.speed === "number"
          ? (current.wind.speed * 3.6).toFixed(1) : "‚Äî";
        const windDir = current.wind && typeof current.wind.deg === "number"
          ? degToCardinal(current.wind.deg) : "‚Äî";
        parts.push(
          `Actuellement √† ${locationName}, ${desc}, ${temp.toFixed(1)} ¬∞C, vent ${windSp} km/h de ${windDir}.`
        );
      }
      if (rainInfo && rainInfo.peak > 0.1) {
        const next = rainInfo.nextRain ? formatTimeHMFromDate(rainInfo.nextRain) : "bient√¥t";
        const end  = rainInfo.endRain ? formatTimeHMFromDate(rainInfo.endRain) : "dans les prochaines heures";
        parts.push(
          `Les prochaines heures (√©chelle 1 h, mod√®le OpenWeather) montrent un risque de pluie √† partir de ${next}, ` +
          `avec une intensit√© maximale estim√©e autour de ${rainInfo.peak.toFixed(1)} mm/h, se terminant vers ${end}.`
        );
      } else {
        parts.push("Les prochaines heures ne montrent pas de pluie significative d'apr√®s la pr√©vision 3 h OpenWeather.");
      }
      if (firstFc && firstFc.main) {
        const t = firstFc.main.temp;
        parts.push(`√Ä la prochaine √©ch√©ance, la temp√©rature pr√©vue est d‚Äôenviron ${t.toFixed(1)} ¬∞C.`);
      }
      return parts.join(" ");
    }

    function buildDailyFromForecast(list) {
      if (!Array.isArray(list)) return { days: [] };
      const byDay = {};
      list.forEach(e => {
        const d = new Date(e.dt * 1000);
        const y = d.getFullYear();
        const m = (d.getMonth() + 1).toString().padStart(2, "0");
        const day = d.getDate().toString().padStart(2, "0");
        const key = `${y}-${m}-${day}`;
        if (!byDay[key]) {
          byDay[key] = {
            date: d,
            tmin: e.main.temp,
            tmax: e.main.temp,
            rain: 0
          };
        } else {
          byDay[key].tmin = Math.min(byDay[key].tmin, e.main.temp);
          byDay[key].tmax = Math.max(byDay[key].tmax, e.main.temp);
        }
        const rain3h = e.rain && typeof e.rain["3h"] === "number" ? e.rain["3h"] : 0;
        byDay[key].rain += rain3h;
      });
      const keys = Object.keys(byDay).sort();
      const days = keys.map(k => {
        const d = byDay[k].date;
        const label = d.toLocaleDateString("fr-FR", { weekday: "short", day: "2-digit", month: "2-digit" });
        return {
          label,
          tmin: byDay[k].tmin,
          tmax: byDay[k].tmax,
          rain: byDay[k].rain
        };
      });
      return { days };
    }

    // ------------- APPELS API -------------

    async function fetchWeatherForLocation(loc) {
      if (!API_KEY || API_KEY === "VOTRE_CLE_API_OPENWEATHER_ICI") {
        throw new Error("Cl√© API OpenWeather manquante ou non configur√©e.");
      }
      const urlCurrent =
        `https://api.openweathermap.org/data/2.5/weather?lat=${loc.lat}&lon=${loc.lon}` +
        `&units=metric&lang=fr&appid=${API_KEY}`;
      const urlForecast =
        `https://api.openweathermap.org/data/2.5/forecast?lat=${loc.lat}&lon=${loc.lon}` +
        `&units=metric&lang=fr&appid=${API_KEY}`;
      const [resCur, resFc] = await Promise.all([fetch(urlCurrent), fetch(urlForecast)]);
      if (!resCur.ok) throw new Error("Erreur API m√©t√©o actuelle : " + resCur.status);
      if (!resFc.ok) throw new Error("Erreur API pr√©vision : " + resFc.status);
      const current = await resCur.json();
      const forecast = await resFc.json();
      const rainInfo = buildRainTimelineFromForecast(forecast.list || []);
      const shortForecast = buildShortForecast(forecast.list || []);
      const temp24 = buildTemp24(forecast.list || []);
      const sunInfo = buildSunInfo(current.sys);
      const daily = buildDailyFromForecast(forecast.list || []);
      const textSummary = buildTextSummary(
        current, rainInfo, (forecast.list && forecast.list[0]) || null, loc.name
      );
      const alerts = [];
      if (current.wind && current.wind.speed * 3.6 > 60)
        alerts.push("Rafales fortes possibles (>60 km/h).");
      if (rainInfo.peak > 5)
        alerts.push("Pluie soutenue attendue dans les prochaines heures.");
      if (!alerts.length)
        alerts.push("Aucune alerte particuli√®re d√©tect√©e (analyse simple).");
      return {
        location: loc,
        current,
        rain_info: rainInfo,
        short_term_forecast: shortForecast,
        sun_moon: sunInfo,
        temp24,
        daily,
        alerts,
        text_summary: textSummary
      };
    }

    async function fetchAirQuality(loc) {
      const url =
        `https://api.openweathermap.org/data/2.5/air_pollution?lat=${loc.lat}&lon=${loc.lon}` +
        `&appid=${API_KEY}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Erreur API qualit√© de l'air : " + res.status);
      return res.json();
    }

    
// --------- BreezoMeter (optionnel) ----------
async function fetchBreezoMeterAirQuality(loc) {
  if (!BREEZO_API_KEY) return null; // pas de cl√© => on ignore proprement
  const url = new URL("https://api.breezometer.com/air-quality/v2/current-conditions");
  url.searchParams.set("lat", loc.lat);
  url.searchParams.set("lon", loc.lon);
  url.searchParams.set("key", BREEZO_API_KEY);
  url.searchParams.set("lang", "fr");
  url.searchParams.set("features", "breezometer_aqi,pollutants_concentrations");
  const res = await fetch(url.toString());
  if (!res.ok) throw new Error("Erreur API BreezoMeter : " + res.status);
  return res.json();
}

// --------- Atmo Data (France) ----------
function getLocalISODate() {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${y}-${m}-${day}`;
}

async function fetchINSEEFromLatLon(loc) {
  const url = new URL("https://geo.api.gouv.fr/communes");
  url.searchParams.set("lat", loc.lat);
  url.searchParams.set("lon", loc.lon);
  url.searchParams.set("fields", "code,nom");
  url.searchParams.set("format", "json");
  url.searchParams.set("geometry", "centre");
  const res = await fetch(url.toString());
  if (!res.ok) throw new Error("Erreur geo.api.gouv.fr : " + res.status);
  const arr = await res.json();
  return (arr && arr[0]) ? arr[0] : null; // { code, nom }
}

// Indice ATMO (id_data=112) ‚Äì voir Atmo Data / Atmo-France
async function fetchAtmoIndiceATMO(codeINSEE, dateISO) {
  if (!codeINSEE) return null;
  const filter = {
    code_zone: { operator: "=", value: codeINSEE },
    date_ech:  { operator: "=", value: dateISO }
  };
  const url = `https://admindata.atmo-france.org/api/data/112/${encodeURIComponent(JSON.stringify(filter))}?withGeom=false`;
  const res = await fetch(url);
  if (!res.ok) throw new Error("Erreur Atmo Data : " + res.status);
  const j = await res.json();
  // API renvoie parfois un tableau directement
  const item = Array.isArray(j) ? j[0] : (j?.data?.[0] ?? null);
  return item || null;
}
async function fetchOpenMeteo(loc) {
      const url =
        `${OPENMETEO_BASE}?latitude=${loc.lat}&longitude=${loc.lon}` +
        "&hourly=temperature_2m,precipitation,cape&forecast_days=3&timezone=auto";
      const res = await fetch(url);
      if (!res.ok) throw new Error("Erreur API Open-Meteo : " + res.status);
      const j = await res.json();
      const h = j.hourly || {};
      const times = h.time || [];
      const temps = h.temperature_2m || [];
      const prec = h.precipitation || [];
      const cape = h.cape || [];

      const nextHours = [];
      for (let i = 0; i < Math.min(5, times.length); i++) {
        const tLabel = times[i].substring(11,16).replace(":", "h");
        nextHours.push({
          time: tLabel,
          temp: typeof temps[i] === "number" ? temps[i] : null,
          precip: typeof prec[i] === "number" ? prec[i] : 0
        });
      }

      let capeNow = 0;
      let capeMax12h = 0;
      for (let i = 0; i < Math.min(12, cape.length); i++) {
        const val = typeof cape[i] === "number" ? cape[i] : 0;
        if (i === 0) capeNow = val;
        if (val > capeMax12h) capeMax12h = val;
      }

      return {
        raw: j,
        nextHours,
        capeNow,
        capeMax12h
      };
    }

    // ------------- RENDUS -------------

    function renderCurrent(data) {
      const loc = data.location;
      const cur = data.current;
      document.getElementById("locationTitle").textContent =
        `Point suivi : ${loc.name} (${loc.lat.toFixed(2)}, ${loc.lon.toFixed(2)})`;
      const desc = translateWeatherDesc(cur.weather[0].description);
      document.getElementById("currentMain").textContent = `Actuellement : ${desc}`;
      document.getElementById("currentTemp").textContent =
        cur.main.temp != null ? `${cur.main.temp.toFixed(1)}¬∞C` : "‚Äî";
      const windKmh = cur.wind && typeof cur.wind.speed === "number"
        ? (cur.wind.speed * 3.6).toFixed(1) : "‚Äî";
      const windDir = cur.wind && typeof cur.wind.deg === "number"
        ? degToCardinal(cur.wind.deg) : "‚Äî";
      const nowStr = formatTimeHMFromDate(new Date());
      document.getElementById("currentExtra").textContent =
        `Vent ${windKmh} km/h de ${windDir} ‚Äì Mise √† jour ${nowStr}`;
      document.getElementById("updateInfo").textContent =
        `${loc.lat.toFixed(2)}, ${loc.lon.toFixed(2)} ‚Äì Maj ${nowStr}`;
    }

    function renderRainChart(data) {
      const canvas = document.getElementById("rainChart");
      const ctx = canvas.getContext("2d");
      const rainInfo = data.rain_info || {};
      const values = rainInfo.timeline || [];
      const maxVal = values.length ? Math.max(...values, 1) : 1;
      const paddingLeft = 40, paddingRight = 15, paddingTop = 20, paddingBottom = 35;
      const w = canvas.width = canvas.clientWidth;
      const h = canvas.height = canvas.clientHeight;
      const innerHeight = h - paddingTop - paddingBottom;
      ctx.clearRect(0, 0, w, h);

      ctx.beginPath();
      ctx.moveTo(paddingLeft, h - paddingBottom);
      ctx.lineTo(w - paddingRight, h - paddingBottom);
      ctx.strokeStyle = "#9ba6c3";
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(paddingLeft, h - paddingBottom);
      ctx.lineTo(paddingLeft, paddingTop);
      ctx.stroke();

      if (values.length > 0) {
        const stepX = (w - paddingLeft - paddingRight) / (values.length - 1 || 1);
        ctx.beginPath();
        for (let i = 0; i < values.length; i++) {
          const x = paddingLeft + i * stepX;
          const y = h - paddingBottom - (values[i] / maxVal) * innerHeight;
          if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = "#4fc3ff";
        ctx.lineWidth = 2;
        ctx.stroke();

        const now = new Date();
        ctx.fillStyle = "#d4daec";
        ctx.font = "10px sans-serif";
        ctx.textAlign = "center";
        for (let i = 0; i < values.length; i++) {
          const x = paddingLeft + i * stepX;
          const t = new Date(now.getTime() + i * 60*60*1000);
          const label = t.toLocaleTimeString("fr-FR", { hour: "2-digit" }).replace(":", "h");
          ctx.fillText(label, x, h - paddingBottom + 12);
        }
        ctx.textAlign = "left";
      }

      ctx.fillStyle = "#d4daec";
      ctx.font = "11px sans-serif";
      ctx.fillText("Intensit√© pluie estim√©e (mm/h, mod√®le OpenWeather)", paddingLeft, paddingTop - 5);

      const summary = document.getElementById("rainSummary");
      if (!values.length || rainInfo.peak <= 0.1) {
        summary.textContent =
          "Pas de signal de pluie significative dans les prochaines heures (d‚Äôapr√®s la pr√©vision 3 h OpenWeather).";
      } else {
        const next = rainInfo.nextRain ? formatTimeHMFromDate(rainInfo.nextRain) : "bient√¥t";
        const end  = rainInfo.endRain ? formatTimeHMFromDate(rainInfo.endRain) : "dans les prochaines heures";
        summary.textContent =
          `Risque de pluie √† partir de ${next}, fin probable vers ${end}. ` +
          `Intensit√© maximale estim√©e : ${rainInfo.peak.toFixed(1)} mm/h (mod√®le OpenWeather).`;
      }
      document.getElementById("rainError").textContent = "";
    }

    function renderTemp24(data) {
      const canvas = document.getElementById("temp24Chart");
      const ctx = canvas.getContext("2d");
      const temps = data.temp24.temps || [];
      const labels = data.temp24.labels || [];
      const rain = data.temp24.rain || [];
      if (!temps.length) { ctx.clearRect(0,0,canvas.width,canvas.height); return; }
      const maxT = Math.max(...temps);
      const minT = Math.min(...temps);
      const maxRain = Math.max(...rain, 0);
      const padding = 35;
      const w = canvas.width = canvas.clientWidth;
      const h = canvas.height = canvas.clientHeight;
      const innerH = h - 2*padding;

      ctx.clearRect(0,0,w,h);

      ctx.beginPath();
      ctx.moveTo(padding, h-padding);
      ctx.lineTo(w-padding, h-padding);
      ctx.strokeStyle = "#9ba6c3";
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(padding, h-padding);
      ctx.lineTo(padding, padding);
      ctx.stroke();

      const stepX = (w - 2*padding) / (temps.length - 1 || 1);
      const range = (maxT - minT) || 1;

      // Barres de pluie avec palette type radar
      if (maxRain > 0) {
        const maxBarH = innerH * 0.45;

        for (let i = 0; i < rain.length; i++) {
          const r = rain[i];
          if (!r || r <= 0) continue;

          const x = padding + i * stepX;
          const baseY = h - padding;
          const barH = (r / maxRain) * maxBarH;
          const barW = stepX * 0.4;

          const mmh = r / 3; // approx mm/h

          let color = "rgba(0, 0, 80, 0.4)";              // tr√®s faible
          if (mmh >= 0.1 && mmh < 0.5)      color = "rgba(0, 80, 200, 0.5)";   // bruine / faible
          else if (mmh >= 0.5 && mmh < 1.3) color = "rgba(0, 150, 80, 0.6)";    // mod√©r√©e
          else if (mmh >= 1.3 && mmh < 3)   color = "rgba(220, 200, 0, 0.7)";   // marqu√©e
          else if (mmh >= 3 && mmh < 6)     color = "rgba(255, 128, 0, 0.8)";   // forte
          else if (mmh >= 6)                color = "rgba(255, 0, 0, 0.85)";    // tr√®s forte

          ctx.fillStyle = color;
          ctx.fillRect(x - barW / 2, baseY - barH, barW, barH);
        }
      }

      ctx.beginPath();
      for (let i = 0; i < temps.length; i++) {
        const x = padding + i * stepX;
        const y = h - padding - ((temps[i] - minT) / range) * innerH;
        if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.strokeStyle = "#ffcc66";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = "#ffdd99";
      ctx.font = "10px sans-serif";
      ctx.textAlign = "center";
      for (let i = 0; i < temps.length; i++) {
        const x = padding + i * stepX;
        const y = h - padding - ((temps[i] - minT) / range) * innerH;
        ctx.fillText(temps[i].toFixed(1) + "¬∞", x, y-6);
      }

      ctx.fillStyle = "#d4daec";
      ctx.textAlign = "left";
      ctx.fillText("Temp√©rature (¬∞C) & pluie (mm/3h)", padding, padding-10);

      ctx.textAlign = "center";
      for (let i = 0; i < labels.length; i++) {
        const x = padding + i * stepX;
        ctx.fillText(labels[i], x, h-padding+12);
      }
      ctx.textAlign = "left";
    }

    function renderShortForecast(data) {
      const tbody = document.querySelector("#shortTable tbody");
      tbody.innerHTML = "";
      const rows = data.short_term_forecast.hours || [];
      if (!rows.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="4">Pas de donn√©es disponibles.</td>`;
        tbody.appendChild(tr);
        return;
      }
      rows.forEach(h => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${h.time}</td>
          <td>${h.temp_c != null ? h.temp_c.toFixed(1) : "‚Äî"}</td>
          <td>${h.rain_mm_3h != null ? h.rain_mm_3h.toFixed(1) : "0.0"}</td>
          <td>${h.wind_kmh != null ? h.wind_kmh.toFixed(1) : "‚Äî"}</td>`;
        tbody.appendChild(tr);
      });
    }

    function renderDailyForecast(data) {
      const tbody = document.querySelector("#dailyTable tbody");
      tbody.innerHTML = "";
      const days = data.daily.days || [];
      if (!days.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="4">Pas de donn√©es quotidiennes disponibles.</td>`;
        tbody.appendChild(tr);
        return;
      }
      days.forEach(d => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${d.label}</td>
          <td>${d.tmin.toFixed(1)}</td>
          <td>${d.tmax.toFixed(1)}</td>
          <td>${d.rain.toFixed(1)}</td>`;
        tbody.appendChild(tr);
      });
    }

    function renderSunMoon(data) {
      const block = document.getElementById("sunMoonBlock");
      const sm = data.sun_moon;
      lastSunInfo = sm;
      block.innerHTML = "";
      const lines = [
        ["Lever du soleil", sm.sunrise],
        ["Coucher du soleil", sm.sunset],
        ["Golden Hour (soir)", `${sm.golden_hour_evening[0]} ‚Äì ${sm.golden_hour_evening[1]}`],
        ["Blue Hour (soir)", `${sm.blue_hour_evening[0]} ‚Äì ${sm.blue_hour_evening[1]}`]
      ];
      lines.forEach(([label,value]) => {
        const row = document.createElement("div");
        row.className = "sun-row";
        row.innerHTML = `<span class="sun-label">${label}</span><span class="sun-value">${value}</span>`;
        block.appendChild(row);
      });
      applyTheme(sm);
    }

    function renderAtmos(data) {
      const cur = data.current;
      const block = document.getElementById("atmContent");
      block.innerHTML = "";
      const t = cur.main && typeof cur.main.temp === "number" ? cur.main.temp : null;
      const feels = cur.main && typeof cur.main.feels_like === "number" ? cur.main.feels_like : null;
      const hum = cur.main && typeof cur.main.humidity === "number" ? cur.main.humidity : null;
      const pres = cur.main && typeof cur.main.pressure === "number" ? cur.main.pressure : null;
      const dew = computeDewPoint(t, hum);
      const lines = [
        ["Temp√©rature", t != null ? `${t.toFixed(1)} ¬∞C` : "‚Äî"],
        ["Ressenti", feels != null ? `${feels.toFixed(1)} ¬∞C` : "‚Äî"],
        ["Humidit√©", hum != null ? `${hum.toFixed(0)} %` : "‚Äî"],
        ["Point de ros√©e", dew != null ? `${dew.toFixed(1)} ¬∞C` : "‚Äî"],
        ["Pression", pres != null ? `${pres.toFixed(0)} hPa` : "‚Äî"]
      ];
      lines.forEach(([label,value]) => {
        const row = document.createElement("div");
        row.className = "atm-row";
        row.innerHTML = `<span class="atm-label">${label}</span><span class="atm-value">${value}</span>`;
        block.appendChild(row);
      });
    }

    function renderAlerts(data) {
      const ul = document.getElementById("alertsList");
      ul.innerHTML = "";
      const alerts = data.alerts || [];
      alerts.forEach(a => {
        const li = document.createElement("li");
        li.textContent = a;
        ul.appendChild(li);
      });
    }

    function renderRadarSummary(data) {
      const rainInfo = data.rain_info;
      const p = document.getElementById("radarSummary");
      if (rainInfo && rainInfo.peak > 0.1) {
        const next = rainInfo.nextRain ? formatTimeHMFromDate(rainInfo.nextRain) : "bient√¥t";
        const end  = rainInfo.endRain ? formatTimeHMFromDate(rainInfo.endRain) : "dans les prochaines heures";
        p.textContent =
          `La pr√©vision interpol√©e (pas 1 h, OpenWeather) laisse envisager des pr√©cipitations √† partir d‚Äôenviron ${next}, se prolongeant jusqu‚Äô√† ${end}.`;
      } else {
        p.textContent =
          "Le radar et la pr√©vision ne montrent pas de pr√©cipitations marqu√©es √† proximit√© imm√©diate (mod√®le OpenWeather).";
      }
    }

    function renderSummaryText(data) {
      document.getElementById("textSummary").textContent = data.text_summary;
    }

    function renderWind(data) {
      const cur = data.current;
      const arrow = document.getElementById("windArrow");
      const labelsDiv = document.getElementById("windLabels");
      const speedKmh = cur.wind && typeof cur.wind.speed === "number"
        ? cur.wind.speed * 3.6 : null;
      const dirDeg = cur.wind && typeof cur.wind.deg === "number"
        ? cur.wind.deg : null;
      if (dirDeg != null) arrow.style.transform = `rotate(${dirDeg}deg)`;
      const dirCard = dirDeg != null ? degToCardinal(dirDeg) : "‚Äî";
      labelsDiv.innerHTML =
        `Direction : ${dirCard} (${dirDeg != null ? dirDeg.toFixed(0) + "¬∞" : "‚Äî"})<br>` +
        `Vitesse : ${speedKmh != null ? speedKmh.toFixed(1) + " km/h" : "‚Äî"}`;
    }

    function pushHistoryEntry(data) {
      const cur = data.current;
      const temp = cur.main && typeof cur.main.temp === "number" ? cur.main.temp : null;
      const windKmh = cur.wind && typeof cur.wind.speed === "number" ? cur.wind.speed * 3.6 : null;
      historyEntries.push({ time: new Date(), temp, windKmh });
      if (historyEntries.length > 8)
        historyEntries = historyEntries.slice(historyEntries.length - 8);
      const tbody = document.getElementById("historyBody");
      tbody.innerHTML = "";
      historyEntries.slice().reverse().forEach(e => {
        const tr = document.createElement("tr");
        tr.innerHTML =
          `<td>${formatTimeHMFromDate(e.time)}</td>` +
          `<td>${e.temp != null ? e.temp.toFixed(1) : "‚Äî"}</td>` +
          `<td>${e.windKmh != null ? e.windKmh.toFixed(1) : "‚Äî"}</td>`;
        tbody.appendChild(tr);
      });
    }

    function renderError(err) {
      console.error(err);
      document.getElementById("globalError").textContent =
        "Erreur lors de la r√©cup√©ration des donn√©es m√©t√©o : " + err.message;
      document.getElementById("rainError").textContent =
        "Impossible d‚Äôafficher l‚Äôestimation de pluie.";
    }

    
function aqiLevelToClass(level) {
  switch (level) {
    case 1: return "aqi-fair";
    case 2: return "aqi-good";
    case 3: return "aqi-moderate";
    case 4: return "aqi-poor";
    case 5: return "aqi-very-poor";
    default: return "aqi-good";
  }
}

function aqiLevelToLabel(level) {
  const labelMap = {
    1: "Tr√®s bon",
    2: "Bon",
    3: "Moyen",
    4: "Mauvais",
    5: "Tr√®s mauvais"
  };
  return labelMap[level] || "‚Äî";
}

function clampLevel(v) {
  const n = Number(v);
  if (!Number.isFinite(n)) return null;
  if (n <= 1) return 1;
  if (n === 2) return 2;
  if (n === 3) return 3;
  if (n === 4) return 4;
  return 5;
}

// Map AQI 0..500 -> 1..5 (√©chelle simple)
function breezoAqiToLevel(aqi) {
  const n = Number(aqi);
  if (!Number.isFinite(n)) return null;
  if (n <= 50) return 1;
  if (n <= 100) return 2;
  if (n <= 150) return 3;
  if (n <= 200) return 4;
  return 5;
}

// Atmo index (souvent 1..6) -> 1..5
function atmoToLevel(atmoCode) {
  if (atmoCode == null) return null;
  const n = Number(atmoCode);
  if (Number.isFinite(n)) {
    if (n <= 1) return 1;
    if (n === 2) return 2;
    if (n === 3) return 3;
    if (n === 4) return 4;
    return 5; // 5 ou 6 => tr√®s mauvais
  }
  const s = String(atmoCode).toLowerCase();
  if (s.includes("tr√®s bon")) return 1;
  if (s.includes("bon")) return 2;
  if (s.includes("moy")) return 3;
  if (s.includes("mauvais") || s.includes("m√©diocre")) return 4;
  if (s.includes("tr√®s mauvais")) return 5;
  return null;
}

function minMax(values) {
  const nums = values.filter(v => typeof v === "number" && Number.isFinite(v));
  if (!nums.length) return null;
  const mn = Math.min(...nums);
  const mx = Math.max(...nums);
  return { mn, mx };
}

function formatRange(values, unit, decimals=1) {
  const mm = minMax(values);
  if (!mm) return "‚Äî";
  if (Math.abs(mm.mx - mm.mn) < 0.05) return `${mm.mn.toFixed(decimals)} ${unit}`;
  return `${mm.mn.toFixed(decimals)}‚Äì${mm.mx.toFixed(decimals)} ${unit}`;
}

function ugm3ToPpb(ugm3, molarMass) {
  // approx standard: 24.45 L/mol √† 25¬∞C, 1 atm
  if (!(typeof ugm3 === "number") || !Number.isFinite(ugm3) || ugm3 <= 0) return null;
  return ugm3 * 24.45 / molarMass;
}

function ugm3ToPpmFromUg(ugm3, molarMass) {
  // ug/m3 -> ppm : ug/m3 -> mg/m3 / (molarMass g/mol) * 24.45
  if (!(typeof ugm3 === "number") || !Number.isFinite(ugm3) || ugm3 <= 0) return null;
  // for CO, molarMass=28.0 g/mol but ug/m3 needs convert to mg/m3:
  const mgm3 = ugm3 / 1000.0;
  return mgm3 * 24.45 / molarMass;
}

function renderAirQualityMulti({ ow, bz, atmo, commune }) {
  const div = document.getElementById("aqiContent");
  div.innerHTML = "";

  // ---- OpenWeather concentrations ----
  let owLevel = null;
  let owLabel = "‚Äî";
  let owPm25=null, owPm10=null, owO3=null, owNo2=null, owSo2=null, owCo=null;

  if (ow?.list?.[0]) {
    const d = ow.list[0];
    owLevel = clampLevel(d?.main?.aqi);
    owLabel = owLevel ? aqiLevelToLabel(owLevel) : "‚Äî";
    const c = d.components || {};
    owPm25 = c.pm2_5 ?? null;
    owPm10 = c.pm10 ?? null;
    owO3   = c.o3   ?? null;
    owNo2  = c.no2  ?? null;
    owSo2  = c.so2  ?? null;
    owCo   = c.co   ?? null;
  }

  // ---- BreezoMeter concentrations ----
  let bzLevel = null;
  let bzAqiText = "‚Äî";
  let bzPm25=null, bzPm10=null, bzO3=null, bzNo2=null, bzSo2=null, bzCo=null;

  if (bz?.data) {
    const idx = bz.data.indexes?.baqi;
    bzLevel = breezoAqiToLevel(idx?.aqi);
    bzAqiText = idx?.aqi != null ? `AQI ${idx.aqi}` : "‚Äî";

    const p = bz.data.pollutants || {};
    bzPm25 = p.pm25?.concentration?.value ?? null;
    bzPm10 = p.pm10?.concentration?.value ?? null;
    bzO3   = p.o3?.concentration?.value   ?? null;
    bzNo2  = p.no2?.concentration?.value  ?? null;
    bzSo2  = p.so2?.concentration?.value  ?? null;
    bzCo   = p.co?.concentration?.value   ?? null;
  }

  // ---- Atmo index (France) ----
  let atmoLevel = null;
  let atmoLabel = "‚Äî";
  if (atmo) {
    // code_qual ou qualite_... selon retours
    const code = atmo.code_qual ?? atmo.code ?? atmo.indice ?? null;
    atmoLevel = atmoToLevel(code);
    atmoLabel = atmoLevel ? aqiLevelToLabel(atmoLevel) : (code != null ? String(code) : "‚Äî");
  }

  // ---- Fusion : on prend le pire niveau dispo ----
  const levels = [owLevel, bzLevel, atmoLevel].filter(v => v != null);
  const fused = levels.length ? Math.max(...levels) : null;
  const fusedLabel = fused ? aqiLevelToLabel(fused) : "‚Äî";
  const fusedClass = aqiLevelToClass(fused || 2);

  // ---- UI : lignes sources ----
  const rowsTop = [
    ["Indice global (fusion)", `<span class="aqi-badge ${fusedClass}">${fused ? fused : "‚Äî"} ‚Äì ${fusedLabel}</span>`],
    ["D√©tail", `OW ${owLevel ?? "‚Äî"} | BZ ${bzAqiText} | Atmo ${atmoLabel}${commune ? ` (${commune})` : ""}`]
  ];

  rowsTop.forEach(([l, v]) => {
    const row = document.createElement("div");
    row.className = "aqi-row";
    row.innerHTML = `<span class="aqi-label">${l}</span><span class="aqi-value">${v}</span>`;
    div.appendChild(row);
  });

  // ---- Ranges concentrations (OW + BZ) ----
  const pm25Txt = formatRange([owPm25, bzPm25], "¬µg/m¬≥", 1);
  const pm10Txt = formatRange([owPm10, bzPm10], "¬µg/m¬≥", 1);

  // gases display like before (ppb/ppm) but as ranges
  const o3ppb  = [ugm3ToPpb(owO3, 48.0), ugm3ToPpb(bzO3, 48.0)];
  const no2ppb = [ugm3ToPpb(owNo2, 46.0), ugm3ToPpb(bzNo2, 46.0)];
  const so2ppb = [ugm3ToPpb(owSo2, 64.0), ugm3ToPpb(bzSo2, 64.0)];
  const coppm  = [ugm3ToPpmFromUg(owCo, 28.0), ugm3ToPpmFromUg(bzCo, 28.0)];

  const o3Txt  = minMax(o3ppb)  ? (Math.max(...o3ppb.filter(v=>v!=null)) < 1 ? "<1 ppb" : formatRange(o3ppb, "ppb", 0)) : "‚Äî";
  const no2Txt = minMax(no2ppb) ? (Math.max(...no2ppb.filter(v=>v!=null)) < 1 ? "<1 ppb" : formatRange(no2ppb, "ppb", 0)) : "‚Äî";
  const so2Txt = minMax(so2ppb) ? (Math.max(...so2ppb.filter(v=>v!=null)) < 1 ? "<1 ppb" : formatRange(so2ppb, "ppb", 0)) : "‚Äî";
  const coTxt  = minMax(coppm)  ? (Math.max(...coppm.filter(v=>v!=null)) < 0.01 ? "<0.01 ppm" : formatRange(coppm, "ppm", 2)) : "‚Äî";

  const rows = [
    ["PM‚ÇÇ.‚ÇÖ", pm25Txt],
    ["PM‚ÇÅ‚ÇÄ", pm10Txt],
    ["O‚ÇÉ", o3Txt],
    ["NO‚ÇÇ", no2Txt],
    ["SO‚ÇÇ", so2Txt],
    ["CO", coTxt],
    ["Source concentrations", "OpenWeather + BreezoMeter"]
  ];

  rows.forEach(([l, v]) => {
    const row = document.createElement("div");
    row.className = "aqi-row";
    row.innerHTML = `<span class="aqi-label">${l}</span><span class="aqi-value">${v}</span>`;
    div.appendChild(row);
  });
}
      function renderModelComparison(owData, omData) {
      const tbody = document.querySelector("#compareTable tbody");
      tbody.innerHTML = "";

      if (!owData || !omData || !omData.nextHours || !owData.short_term_forecast.hours) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="4">Donn√©es mod√®les indisponibles.</td>`;
        tbody.appendChild(tr);
        return;
      }

      const ow = owData.short_term_forecast.hours;
      const om = omData.nextHours;
      const n = Math.min(ow.length, om.length, 3);

      for (let i = 0; i < n; i++) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${ow[i].time}</td>
          <td>${ow[i].temp_c != null ? ow[i].temp_c.toFixed(1) : "‚Äî"}</td>
          <td>${om[i].temp != null ? om[i].temp.toFixed(1) : "‚Äî"}</td>
          <td>${ow[i].rain_mm_3h != null ? ow[i].rain_mm_3h.toFixed(1) : "0.0"} / ${om[i].precip.toFixed(1)}</td>`;
        tbody.appendChild(tr);
      }
    }

    function renderStormRisk(omData) {
      const div = document.getElementById("stormContent");
      if (!omData) {
        div.textContent = "Donn√©es Open-Meteo indisponibles.";
        return;
      }

      const capeNow = typeof omData.capeNow === "number" ? omData.capeNow : 0;
      const maxVal  = typeof omData.capeMax12h === "number" ? omData.capeMax12h : 0;

      let niveau = "Faible";
      if (maxVal > 400 && maxVal <= 800) niveau = "Mod√©r√©";
      else if (maxVal > 800 && maxVal <= 1500) niveau = "Marqu√©";
      else if (maxVal > 1500) niveau = "Fort";

      let riskClass = "storm-low";
      if (niveau === "Mod√©r√©") riskClass = "storm-moderate";
      else if (niveau === "Marqu√©") riskClass = "storm-marked";
      else if (niveau === "Fort") riskClass = "storm-strong";

      div.innerHTML = "";

      const rows = [
        ["CAPE actuel", `${capeNow.toFixed(0)} J/kg`],
        ["CAPE max 12 h", `${maxVal.toFixed(0)} J/kg`],
        [
          "Risque orageux (simple)",
          `<span class="storm-badge ${riskClass}">${niveau}</span>`
        ]
      ];

      rows.forEach(([l, v]) => {
        const row = document.createElement("div");
        row.className = "storm-row";
        row.innerHTML =
          `<span class="storm-label">${l}</span><span class="storm-value">${v}</span>`;
        div.appendChild(row);
      });
    }

    // ------------- CHARGEMENT GLOBAL -------------

    async function loadAndRender() {
      try {
        const loc = LOCATIONS[currentLocationKey];

        const [owRes, omRes, aqiRes, bzRes, inseeRes] = await Promise.allSettled([
          fetchWeatherForLocation(loc),
          fetchOpenMeteo(loc),
          fetchAirQuality(loc),
          fetchBreezoMeterAirQuality(loc),
          fetchINSEEFromLatLon(loc)
        ]);

        if (owRes.status !== "fulfilled") {
          throw owRes.reason;
        }

        const owData = owRes.value;

        renderCurrent(owData);
        renderRainChart(owData);
        renderTemp24(owData);
        renderShortForecast(owData);
        renderDailyForecast(owData);
        renderSunMoon(owData);
        renderAtmos(owData);
        renderAlerts(owData);
        renderRadarSummary(owData);
        renderSummaryText(owData);
        renderWind(owData);
        pushHistoryEntry(owData);
        updateLeafletMap(loc);

        if (omRes.status === "fulfilled") {
          const omData = omRes.value;
          renderModelComparison(owData, omData);
          renderStormRisk(omData);
        } else {
          renderModelComparison(null, null);
          document.getElementById("stormContent").textContent = "Donn√©es Open-Meteo indisponibles.";
        }

        
// Qualit√© de l'air multi-sources
const owAqi = (aqiRes.status === "fulfilled") ? aqiRes.value : null;
const bzAqi = (bzRes.status === "fulfilled") ? bzRes.value : null;

let communeNom = null;
let atmoItem = null;
if (inseeRes.status === "fulfilled" && inseeRes.value) {
  communeNom = inseeRes.value.nom || null;
  try {
    atmoItem = await fetchAtmoIndiceATMO(inseeRes.value.code, getLocalISODate());
  } catch (e) {
    // Atmo indisponible -> on continue sans bloquer
    atmoItem = null;
  }
}

if (owAqi || bzAqi || atmoItem) {
  renderAirQualityMulti({ ow: owAqi, bz: bzAqi, atmo: atmoItem, commune: communeNom });
} else {
  document.getElementById("aqiContent").textContent = "Donn√©es qualit√© de l‚Äôair indisponibles.";
}

        document.getElementById("globalError").textContent = "";
      } catch (e) {
        renderError(e);
      }
    }

    // ------------- INITIALISATION -------------

    document.addEventListener("DOMContentLoaded", () => {
      loadCustomLocations();
      loadCurrentLocationKey();
      loadRadarMode();
      loadThemeMode();
      loadLayoutMode();
      rebuildLocations();
      rebuildLocationSelect();

      applyLayoutMode();

      const select = document.getElementById("locationSelect");
      select.addEventListener("change", () => {
        currentLocationKey = select.value;
        saveCurrentLocationKey();
        historyEntries = [];
        document.getElementById("historyBody").innerHTML = "";
        updateRadarFrames();
        loadAndRender();
        updateDeleteButtonState();
      });

      document.getElementById("addLocationBtn")
        .addEventListener("click", handleAddLocation);
      document.getElementById("geoLocateBtn")
        .addEventListener("click", askGeolocation);


      document.getElementById("deleteLocationBtn")
        .addEventListener("click", handleDeleteLocation);

      document.getElementById("btnRadarMode").addEventListener("click", () => {
        radarMode = "radar";
        saveRadarMode();
        updateRadarFrames();
      });
      document.getElementById("btnRainMode").addEventListener("click", () => {
        radarMode = "rain";
        saveRadarMode();
        updateRadarFrames();
      });

      document.getElementById("themeToggleBtn").addEventListener("click", toggleThemeMode);
      document.getElementById("layoutToggleBtn").addEventListener("click", toggleLayoutMode);

      initLeafletMap();
      updateRadarFrames();
      applyTheme(null);

      // Auto-g√©oloc si la permission est d√©j√† accord√©e
      if (navigator.permissions && navigator.permissions.query) {
        navigator.permissions.query({ name: "geolocation" }).then((result) => {
          if (result.state === "granted") {
            askGeolocation();
          }
        }).catch(() => {});
      }

      loadAndRender();
      setInterval(loadAndRender, 5 * 60 * 1000); // toutes les 5 minutes
    });
  </script>
</body>
</html>
